AWSTemplateFormatVersion: "2010-09-09"

######
# Optional:
# Modify instance type and AMI image
######

Parameters:

  InstanceTypeParameter:
    Type: String
    Default: t2.medium
    Description: Enter instance size.

  # Use Amazon Linux 2 AMI for C2 servers
  AMI:
    Type: String
    Default: ami-0c02fb55956c7d316
    Description: The Linux AMI to use.

  # Your existing C2 (hostname or IP). Lambda will forward traffic here. Leave empty to use the EC2 in this stack.
  TeamServerAddress:
    Type: String
    Default: ""
    Description: Existing C2 hostname or IP (e.g. c2.example.com or 10.1.2.3). Leave empty to forward to the EC2 in this stack.

  # Scheme and port for the backend (only used when TeamServerAddress is set).
  TeamServerScheme:
    Type: String
    Default: "https"
    AllowedValues:
      - http
      - https
    Description: Use http if your C2 listener is on HTTP (e.g. port 80).
  TeamServerPort:
    Type: String
    Default: "443"
    Description: Port your C2 listens on (e.g. 80 for HTTP, 443 for HTTPS, or 7443).

Conditions:
  UseExternalC2: !Not [!Equals [!Ref TeamServerAddress, ""]]

######
# Part 1:
# Create the core VPC/subnet components
######

Resources:

  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-VPC

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    DependsOn: VPC
    Properties:
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-InternetGW

  AttachGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway

  Subnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.0.0/24
      AvailabilityZone: us-east-1a  # Change to desired AZ
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-Subnet

  RouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-RouteTable

  # Make sure instances in subnet can access the internet
  RouteInternetAccess:
    Type: AWS::EC2::Route
    DependsOn: AttachGateway
    Properties:
      RouteTableId: !Ref RouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  # Apply internet-accessible routing table to subnets
  SubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref Subnet
      RouteTableId: !Ref RouteTable

######
# Part 2:
# Create Security Groups and C2 Instances
######

  Ec2InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonEC2RoleforSSM
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ ec2.amazonaws.com ]
            Action:
              - sts:AssumeRole
      Path: /

  Ec2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles: [ !Ref Ec2InstanceRole ]

  SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub ${AWS::StackName}-SecurityGroup
      GroupDescription: "Only 80 and 443 traffic allowed. Use SSM to connect to instance cli."
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-SecurityGroup
      SecurityGroupIngress:
        - IpProtocol: tcp
          CidrIp: 10.0.0.0/24
          FromPort: 443
          ToPort: 443
        - IpProtocol: tcp
          CidrIp: 10.0.0.0/24
          FromPort: 1024
          ToPort: 65535
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0

  C2Server:
    Type: "AWS::EC2::Instance"
    Properties:
      ImageId: !Ref AMI
      InstanceType:
        Ref: InstanceTypeParameter
      IamInstanceProfile: !Ref Ec2InstanceProfile
      NetworkInterfaces:
        - AssociatePublicIpAddress: true
          DeviceIndex: 0
          SubnetId: !Ref Subnet
          GroupSet:
            - Ref: SecurityGroup
      BlockDeviceMappings:
        - DeviceName: "/dev/xvda"
          Ebs:
            VolumeSize: "10"
            DeleteOnTermination: "true"
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-C2Server

######
# Part 3:
# TODO: Create Lambda Redirector
######

  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-LambdaRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-LambdaRole-Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: "Allow"
                Action:
                - ec2:CreateNetworkInterface
                - ec2:DeleteNetworkInterface
                - ec2:DescribeInstances
                - ec2:AttachNetworkInterface
                - ec2:DescribeNetworkInterfaces
                Resource: "*"
      AssumeRolePolicyDocument:
        Statement:
          - Action:
            - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
              - lambda.amazonaws.com
        Version: 2012-10-17
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AWSLambdaExecute
        - arn:aws:iam::aws:policy/AmazonS3FullAccess
      Path: /

  LambdaRedirector:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-LambdaRedirector
      Description: Lambda Function used as a redirector to TEAMSERVER
      Handler: index.redirector
      Runtime: python3.12
      Timeout: 30
      Role: !GetAtt LambdaRole.Arn
      # When using external C2, Lambda must run without VPC to reach the internet (no NAT in this template).
      # When using in-stack EC2, Lambda stays in VPC to reach C2Server by private IP.
      VpcConfig: !If
        - UseExternalC2
        - !Ref AWS::NoValue
        - SubnetIds:
            - !Ref Subnet
          SecurityGroupIds:
            - !Ref SecurityGroup
      Environment:
        Variables:
          TEAMSERVER: !If [UseExternalC2, !Ref TeamServerAddress, !GetAtt C2Server.PrivateIp]
          TEAMSERVER_SCHEME: !If [UseExternalC2, !Ref TeamServerScheme, "https"]
          TEAMSERVER_PORT: !If [UseExternalC2, !Ref TeamServerPort, "443"]
      Code:
        ZipFile: |
          import base64
          import os
          import ssl
          from urllib.request import Request, urlopen
          from urllib.error import HTTPError, URLError


          def redirector(event, context):
              try:
                  print(event)

                  teamserver = os.getenv("TEAMSERVER")
                  if not teamserver:
                      return {"statusCode": 500, "body": "TEAMSERVER not configured", "headers": {}}

                  scheme = os.getenv("TEAMSERVER_SCHEME", "https")
                  port = os.getenv("TEAMSERVER_PORT", "443")
                  path = event.get("requestContext", {}).get("http", {}).get("path", "/")
                  # Special path: return the Lambda's outbound IP (so you can whitelist it on your teamserver)
                  if path.rstrip("/") == "/lambda-egress-ip":
                      try:
                          ip_resp = urlopen(Request("https://checkip.amazonaws.com"), timeout=5)
                          egress_ip = ip_resp.read().decode("utf-8").strip()
                          return {"statusCode": 200, "body": egress_ip, "headers": {"Content-Type": "text/plain"}}
                      except Exception as e:
                          return {"statusCode": 500, "body": "Could not get egress IP: " + str(e), "headers": {"Content-Type": "text/plain"}}
                  base = scheme + "://" + teamserver
                  if (scheme == "https" and port != "443") or (scheme == "http" and port != "80"):
                      base += ":" + port
                  url = base + path

                  # Use rawQueryString to preserve exact format (order, multi-value params, encoding)
                  # C2 implants require the query string as-sent; queryStringParameters parsing can corrupt it
                  raw_qs = event.get("rawQueryString") or ""
                  if raw_qs:
                      url = url + "?" + raw_qs

                  method = event.get("requestContext", {}).get("http", {}).get("method", "GET")
                  inbound_headers = dict(event.get("headers") or {})
                  # Backend often expects Host: teamserver (e.g. for vhost or CDN routing)
                  inbound_headers["Host"] = teamserver if ":" not in teamserver else teamserver.split(":")[0]
                  # For GET/HEAD: don't forward Content-Length or Transfer-Encoding (we send no body).
                  # Forwarding them causes 400 when teamserver expects a body that never arrives.
                  if method in ("GET", "HEAD"):
                      for h in ("content-length", "content-type", "transfer-encoding"):
                          inbound_headers.pop(h, None)

                  body = b""
                  if event.get("body"):
                      if event.get("isBase64Encoded"):
                          body = base64.b64decode(event["body"])
                      else:
                          body = event["body"].encode("utf-8") if isinstance(event["body"], str) else event["body"]
                  if method not in ("GET", "POST", "HEAD"):
                      return {"statusCode": 405, "body": "Method not allowed", "headers": {}}

                  ctx = ssl.create_default_context()
                  ctx.check_hostname = False
                  ctx.verify_mode = ssl.CERT_NONE
                  req = Request(url, data=body if method == "POST" else None, headers=inbound_headers, method=method)
                  if method == "HEAD":
                      req.get_method = lambda: "HEAD"
                  try:
                      resp = urlopen(req, context=ctx, timeout=25)
                      status, out_body, out_headers = resp.status, resp.read(), dict(resp.headers)
                  except HTTPError as e:
                      status, out_body, out_headers = e.code, e.read(), dict(e.headers)
                  except URLError as e:
                      return {"statusCode": 502, "body": "Backend unreachable: " + str(e.reason), "headers": {"Content-Type": "text/plain"}}

                  return {
                      "statusCode": status,
                      "body": out_body.decode("utf-8", errors="replace"),
                      "headers": out_headers
                  }
              except Exception as e:
                  import traceback
                  err = traceback.format_exc()
                  print(err)
                  return {"statusCode": 500, "body": "Lambda error: " + str(e) + "\n" + err, "headers": {"Content-Type": "text/plain"}}
  LambdaRedirectorURL:
    Type: AWS::Lambda::Url
    DependsOn: LambdaRedirector
    Properties:
      AuthType: NONE
      TargetFunctionArn: !GetAtt LambdaRedirector.Arn

  LambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunctionUrl
      FunctionName: !GetAtt LambdaRedirector.Arn
      FunctionUrlAuthType: NONE
      Principal: '*'


######
# Part 4:
# Output C2 public IP addresses
######

Outputs:
  C2PublicIP:
    Description: "C2 Public IP"
    Value: !GetAtt C2Server.PublicIp
